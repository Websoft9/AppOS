# Epic 16: SSH Tunnel – Local Server Management

**Module**: Infrastructure | **Status**: Done | **Priority**: P1 | **Depends on**: Epic 15

## Overview

Enable servers behind NAT (no public IP) to connect into appos via reverse SSH tunnel. Once connected, they are managed identically to direct-SSH servers — Terminal, Files, and Docker all work without modification.

No agent required on the local server. Connection is established with a single `autossh` command generated by appos.

---

## Architecture

```
Local server (behind NAT)
  autossh -R 0:localhost:22 -R 0:localhost:80 {TOKEN}@appos:2222
  │  Token is the SSH username. No password prompt, autossh-friendly.

internal/tunnel/          ← pure infrastructure, zero business logic
  server.go               ← SSH server, listens on :2222, Token-as-username auth
  portpool.go             ← persistent port pool (pre-loaded from DB at startup)
  token.go                ← token parsing and validation
  session.go              ← tunnel session lifecycle, heartbeat

routes/tunnel.go          ← business layer: PocketBase integration, servers state

Internal port mapping (never exposed publicly):
  127.0.0.1:42001  ←→  local server :22   → SSHConnector (existing, unchanged)
  127.0.0.1:42002  ←→  local server :80   → available for future proxy wiring
```

**HTTP forwarding scope**: The tunnel infrastructure forwards `:80` as a second `-R` in the same SSH session — no extra implementation. How the public reverse proxy routes traffic to `127.0.0.1:42002` is a deployment concern deferred to the App Deployment epic.

### Port lifecycle

```
First connect:
  Token validated → server has no tunnel_services yet
  portpool.Allocate(serverID) → picks free ports from configured range
  tunnel_services written to DB: [{ssh,22,42001},{http,80,42002}]

appos restart:
  portpool.LoadExisting() reads all servers with tunnel_services from DB
  allocated ports are pre-reserved — never reassigned to another server

Reconnect (after appos restart or local server reboot):
  Token validated → server already has tunnel_services in DB
  portpool.Reuse(serverID) → binds the same 42001/42002
  No DB write needed. Nginx config remains valid. ✓

Server deleted:
  tunnel_services cleared in DB
  portpool releases ports back to the free pool

Port conflict fallback:
  if a persisted port is already occupied on appos host startup,
  portpool allocates a new free port in range,
  updates `tunnel_services` in DB,
  and writes an audit event for traceability
```

**Result**: ports are stable across all restarts. Nginx/proxy config written once, never needs updating.

---

## Data Model

### `servers` collection — new fields

| Field | Type | Description |
|-------|------|-------------|
| `connect_type` | text | `direct` (existing default) \| `tunnel` (new) |
| `tunnel_status` | text | `online` \| `offline` |
| `tunnel_last_seen` | datetime | last heartbeat timestamp, for audit |
| `tunnel_services` | json | forwarded port registry — **written by backend on first connect, never by user** |

`tunnel_services` — populated automatically when the tunnel is first established. Schema supports arbitrary future entries beyond SSH + HTTP:

```json
[
  { "name": "ssh",  "local_port": 22, "tunnel_port": 42001 },
  { "name": "http", "local_port": 80, "tunnel_port": 42002 }
]
```

### `host` field for tunnel servers

`connect_type = tunnel` servers store no meaningful `host`. The `resolveServerConfig` function is extended: when `connect_type = tunnel`, it reads `tunnel_services[name=ssh].tunnel_port` and overrides:

```
cfg.Host = "127.0.0.1"
cfg.Port = tunnel_services[ssh].tunnel_port  // e.g. 42001
```

All existing connectors (SSH terminal, SFTP, Docker exec) work unchanged — they only see `cfg.Host` and `cfg.Port`.

### Token storage

Reuses `secrets` collection (`type = tunnel_token`), AES-encrypted, linked via `servers.credential`. The Token is used as the **SSH username** in the autossh command — no password required, no interactive prompt. Token never expires automatically; manual rotation supported with an explicit warning in the Dashboard (rotation immediately disconnects the active tunnel).

Token format must be SSH-safe and URL-safe (recommended: base32/base58 without special symbols), so it can be used directly in `{TOKEN}@appos:2222` and setup URLs without escaping issues.

### Port range (system settings)

Configurable in `Settings → Infrastructure → Tunnel`:

| Setting | Default | Description |
|---------|---------|-------------|
| `tunnel.port_range_start` | `40000` | First port in the allocation pool |
| `tunnel.port_range_end` | `49999` | Last port in the allocation pool |

portpool reads these at startup. With SSH + HTTP (2 ports per server), this default range supports up to ~5,000 concurrent tunnel servers per appos instance.

---

## Key Decisions

| Decision | Resolution |
|----------|------------|
| Tunnel server implementation | `golang.org/x/crypto/ssh` (already a dependency), embedded in appos process, listens on `:2222` |
| Token position in SSH | Used as **username** (`{TOKEN}@appos:2222`), not password — no interactive prompt, autossh-friendly |
| Agent | None. Local server only needs standard OpenSSH client + autossh |
| User onboarding | appos generates `autossh` command + systemd unit; user copies and runs. Setup script installs autossh if absent |
| Port assignment | **Persistent**: allocated on first connect, stored in `tunnel_services`, reused on every reconnect. portpool pre-loads existing assignments from DB at startup |
| Port range | Configurable in system settings (`40000–49999` default). Assigned by appos; local server is unaware |
| `host` field for tunnel servers | `resolveServerConfig` overrides `cfg.Host=127.0.0.1`, `cfg.Port=tunnel_services[ssh].tunnel_port` |
| `tunnel_services` creation | Written by backend automatically on first tunnel establishment, never by the user |
| HTTP multi-app routing | Transport only in this Epic. Public reverse proxy wiring is deferred to App Deployment epic |
| Public exposure | Tunnel ports bound to `127.0.0.1` only. Public `:80/:443` handled by existing Nginx |
| Resource monitoring | This Epic covers `online`/`offline` only. Metrics deferred to Monitor epic |
| Token rotation | Manual on-demand via `?rotate=true`; explicit UI warning deferred (API-accessible). Rotation immediately disconnects active tunnel |
| Wizard status detection | PocketBase Realtime subscription on `servers` record — no polling needed |
| Duplicate token / kick | Last-writer-wins: new connection kicks old one. `Register` closes old SSH conn; `UnregisterConn` prevents race where kicked session's defer removes the new session |
| Token idempotence | `POST /token` is idempotent by default — returns existing token without rotation or disconnect. Rotation requires explicit `?rotate=true` |
| `POST /token` idempotence | Wizard calls `GET /setup` first; only calls `POST /token` if no token exists yet. Prevents accidental tunnel disconnect on wizard open |
| Keepalive | Server sends `keepalive@openssh.com`; liveness is determined by response receipt (any reply), not the `ok` bool (OpenSSH always replies false to unknown global requests) |

---

## Backend API

Authenticated routes under `/api/ext/tunnel/`, require `RequireSuperuserAuth()`:

| Method | Path | Description |
|--------|------|-------------|
| POST | `/api/ext/tunnel/servers/:id/token` | Return existing token (idempotent) or generate first-time token. Add `?rotate=true` to force rotation + disconnect |
| GET | `/api/ext/tunnel/servers/:id/setup` | Return `token`, `autossh_cmd`, `systemd_unit`, `setup_script_url` |
| GET | `/api/ext/tunnel/servers/:id/status` | Query current `online`/`offline` state from in-memory registry |

Unauthenticated route (registered on `se.Router`, not under `/api/ext`):

| Method | Path | Description |
|--------|------|-------------|
| GET | `/tunnel/setup/{token}` | Setup shell script (`text/x-sh`), installs autossh + systemd service |

Tunnel entry point: `:2222` (TCP, SSH protocol).

---

## Frontend

### Add Server — extended flow

A `connect_type` selector is added at the top of the existing Add Server dialog:

```
Connection Type
  ◉ Direct SSH   ← existing form, unchanged
  ○ Tunnel       ← new two-phase wizard
```

### Tunnel setup wizard

**Phase 1** (appos side): fill Name / Description / Groups / SSH credentials (user, auth type, credential) → Create → Token auto-generated.

**Phase 2** (local server side): wizard displays ready-to-run commands, subscribes to the `servers` record via PocketBase Realtime, closes automatically when `tunnel_status` changes to `online`.

```
┌─────────────────────────────────────────────┐
│ Run on your local server:                   │
│                                             │
│  autossh -M 0 -N \                          │
│    -R 0:localhost:22 \                      │
│    -R 0:localhost:80 \                      │
│    -p 2222 {TOKEN}@appos.example.com        │
│                               [Copy]        │
│                                             │
│  Or install as a system service:            │
│  curl .../tunnel/setup/{TOKEN} | bash       │
│                               [Copy]        │
│                                             │
│  Waiting for connection...  ● ○ ○  [Later]  │
└─────────────────────────────────────────────┘
```

### Servers list

`tunnel_status` shown as a badge (`online` = green, `offline` = grey). `connect_type = tunnel` rows omit the Host column.

---

## Security

- Token stored AES-encrypted; used as SSH username for tunnel authentication (no interactive password channel)
- TCP accept loop rate-limited (connection rate + concurrent pending handshakes) to mitigate scanner abuse
- Tunnel ports bound to `127.0.0.1` only — never publicly exposed
- Tunnel connect / disconnect events written to the audit log (Epic 12)
- Token rotation: old token invalidated immediately

---

## Out of Scope

- Public reverse proxy wiring for HTTP apps → App Deployment epic
- Arbitrary TCP port forwarding → schema already supports it; implementation deferred
- UDP forwarding
- Resource metrics (CPU / memory / disk) → Monitor epic
- Multi-tunnel failover / load balancing
- Additional auth beyond token (mTLS, etc.)

---

## Stories

| Story | Title | Key Deliverables |
|-------|-------|-----------------|
| 16.1 | Tunnel Infrastructure | `internal/tunnel/` package: SSH server (`:2222`), port pool, Token auth, session lifecycle, multi-port forward (SSH + HTTP) |
| 16.2 | Server Onboarding | `servers` schema migration, Token API, setup command generation, onboarding wizard UI, realtime `online`/`offline` status |

| Story | Status |
|-------|--------|
| 16.1 | done |
| 16.2 | done |
